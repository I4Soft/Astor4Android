\documentclass{article}
\usepackage[utf8]{inputenc}

\title{Ingredient Strategy}
\author{Matias Martinez and Martin Monperrus}

%\email{https://github.com/SpoonLabs/astor}

\usepackage{natbib}
\usepackage{graphicx}

\begin{document}
\date{}

\maketitle

\begin{abstract}
This document introduces and describes the classes related to Ingredient search space.
If you have any doubt or suggestion, please contact to the authors Matias Martinez and Martin Monperrus.

\end{abstract}


\section{Introduction}
A redundancy-based repair approach such as GenProg uses code written somewhere else in the application under repair to synthesize patches. 
We call \emph{ingredient} to a piece of code (statement) used to synthesize a patch.
The approach takes ingredients from an \emph{ingredient search space}.
As consequence, every patch generated by jGenProg is formed by  ingredients taken from this space.

The current implementation of Astor works at the level of \emph{statements}.
That means that the ingredient space is composed of statements.
Let's continue this report by explaining how to extend the ingredient space is built and how jGenProg navigate it.

\subsection{Ingredient Space Definition}
jGenProg builds the ingredient search space by taking ingredients from the same application under repair. 
Astor is able to define three different ingredients spaces: 
A \emph{Local} space include all ingredients from the files that contains at least one suspicious statement. 
A \emph{Package} space contains all ingredients from the package that contains at least one suspicious statement.
A \emph{Global} contains all ingredient from the application.

Now, let us introduce the classes that represent the Ingredient Space.

Abstract class {\tt IngredientSpace'} defines the interface of a ingredient space.
It defines the methods:

{\tt defineSpace(ProgramVariant):} creates the search space for a specific variant.

{\tt getIngredients(L):} returns all the ingredients included in L.

{\tt getIngredients(L, T):} returns all ingredients of type T included in L.

{\tt setIngredients(L, List<I>):} puts a list of ingredient in L.
	

{\tt spaceScope():} returns the scope of the space (a constant). 

Astor provides concretes ingredients spaces: 
{\tt LocalIngredientSpace}, {\tt PackageIngredientSpace} and {\tt GlobalIngredientSpace}.
All of those spaces extends from {\tt AstorIngredientSpace} class, a class that provides an implemententation of{\tt IngredientSpace} using  Map structures.


If you want to create your own Ingredient space you can extends from `IngredientSpace' (and to implement the data structures) or from AstorIngredientSpace and reuse the methods provided by this class.

Note that the responsibility of a IngredientSpace is to store ingredients and organize it according to the scope. For instance, the a local scope puts together all the ingredients that belongs to the same file, while the package scope puts all ingredients that belong to classes of the same package.
As we present in next section, we delegate the navigation of this space to  to classes that extend form `IngredientSearchStrategy'.  

\subsection{Ingredient Space Navigation}

Astor can navigate i.e., selects ingredients from the space, in several ways, for instance, in a randomly way.
The class {\tt IngredientSearchStrategy} defines a navigation strategy. It receives an IngredientSpace as parameter and defines the following methods:

{\tt getFixIngredient(ModificationPoint, AstorOperator):} returns a ingredient given a modification point and a operator. Note that later Astor will synthesize a patch that includes the returned ingredient. That patch applies the operator in the mentioned point. 

{\tt getIngredientSpace():} returns the complete ingredient space.

We implement a concrete class {\tt UniformRandomIngredientSearch}, that  returns randomly an ingredient. Moreover, {\tt EfficientIngredientStrategy} extends that class for avoid returning twice the same ingredient.

Finally, the canonical name of this strategy's class is passed to Astor via the argument '-ingredientstrategy'. By default, Astor uses EfficientIngredientStrategy.

\section{Example: Shortest Ingredient Strategy}  
In the current distribution we include as example a customized Ingredient Search space called {\tt ShortestIngredientSearchStrategy}. 
This strategy returns the smallest ingredient of the space and removes it from the space.
You can find two test cases at {\tt IngredientSpaceTest} that use and assert this strategy.




%\section{Conclusion}


\bibliographystyle{plain}
\bibliography{references}
\end{document}
